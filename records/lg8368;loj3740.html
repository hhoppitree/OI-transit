<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>[lg8367][loj3739][LNOI2022] 盒</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0,T_1,\cdots,T_l)$，满足：</p>
		<ul>
            <li>$T_0$ 是 $S$ 的子串；</li>
            <li>$\forall1\le i\le l$，$|T_i|-|T_{i-1}|=1$；</li>
            <li>$\forall 1 \le i \le l$，存在 $S$ 的一个长度为 $|T_i|+1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $|T_{i-1}|$ 的前缀为 $T_{i-1}$，长度为 $|T_i|$ 的后缀为 $T_i$。</li>
        </ul>
        <p>输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。
        <p><strong>多组数据</strong>，$|S|\le5\times10^5$，$\sum|S|\le1.5\times10^6$。</p>

		<h3>题解</h3>
		<p>发现 $T$ 不好考虑，所以转为考虑 $S'$。</p>
		<p>发现，从 $S'_i$（记其在原串中的位置为 $[l,r]$）转化到 $S'_{i-1}$ 的过程中，相当于把区间 $[l,r]$ 改为 $[l-2,r-1]$（如果 $S'_i$ 在原串中有多个匹配，任取一个即可）。</p>
		<p>于是我们就得到了一个答案的下界 $\left\lfloor\dfrac{n}{2}\right\rfloor$。</p>
		<p>考虑什么时候答案可以更大，发现，若字符串 $S$ 的 $[a,b]$ 内的下标构成的字符串与 $[c,d]$ 内的下标构成的字符串相等（$a&lt;c$），则可以在这两个字符串之间反复横跳，此时答案为 $d-c+1+\left\lfloor\dfrac{n-d}{2}\right\rfloor$，所以用一个后缀自动机维护即可，每一个等价类只需要考虑其最长的子串中最后的出现位置，总时间复杂度单组询问 $\mathcal{O}(|S|)$。</p>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 5e5 + 5;

struct op
{
    int len, link, nxt[26], siz, pos;
} p[N &lt;&lt; 1];

int n, lst, cnt;

int newNode()
{
    ++cnt;
    p[cnt].len = p[cnt].link = p[cnt].siz = 0;
    p[cnt].pos = n + 1;
    for (int i = 0; i &lt; 26; ++i) {
        p[cnt].nxt[i] = 0;
    }
    return cnt;
}

void insert(int c, int pos)
{
    int x = newNode(), t = lst;
    lst = x;
    p[x].len = p[t].len + 1;
    ++p[x].siz;
    p[x].pos = pos;
    while (~t &amp;&amp; !p[t].nxt[c]) {
        p[t].nxt[c] = x;
        t = p[t].link;
    }
    if (!~t) {
        return;
    }
    int tp = p[t].nxt[c];
    if (p[t].len + 1 == p[tp].len) {
        p[x].link = tp;
    } else {
        int clone = ++cnt;
        p[clone] = p[tp];
        p[clone].len = p[t].len + 1;
        while (~t &amp;&amp; p[t].nxt[c] == tp) {
            p[t].nxt[c] = clone;
            t = p[t].link;
        }
        p[x].link = p[tp].link = clone;
    }
    return;
}

int tmp[N], sx[N &lt;&lt; 1];

signed main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        string s;
        cin &gt;&gt; s;
        cnt = -1;
        lst = newNode();
        p[0].link = -1;
        n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            insert(s[i] - &#x27;a&#x27;, i + 1);
            tmp[i] = 0;
        }
        tmp[n] = 0;
        for (int i = 1; i &lt;= cnt; ++i) {
            ++tmp[p[i].len];
        }
        for (int i = 1; i &lt;= n; ++i) {
            tmp[i] += tmp[i - 1];
        }
        for (int i = 1; i &lt;= cnt; ++i) {
            sx[tmp[p[i].len]--] = i;
        }
        int A = n / 2;
        for (int i = cnt; i &gt;= 1; --i) {
            p[p[sx[i]].link].siz += p[sx[i]].siz;
            p[p[sx[i]].link].pos = min(p[p[sx[i]].link].pos, p[sx[i]].pos);
            if (p[sx[i]].siz &gt;= 2) {
                A = max(A, p[sx[i]].len + ((n - p[sx[i]].pos) &gt;&gt; 1));
            }
        }
        printf(&quot;%d\n&quot;, A);
    }
    return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>
	</body>
</html>