<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>[lg8352][loj3724][SDOI/SXOI2022] 小 N 的独立集</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>小 N 生成了一个 $n$ 个点的树，并选定了一个正整数 $k$。每生成一组数据时，他只需要对于每个点，随机生成一个在 $1\sim k$ 之间的整数点权，就可以生成一个最大独立集问题。</p>
        <p>小 N 把这些题给了他的好朋友，小 Ω。小 Ω 表示，这些题太多太乱了，他打算把所有的 $k^n$ 道题归类处理。一个自然的想法就是按答案（也就是最大权独立集中的点的权值之和）分类，显然这些最大权独立集问题的答案一定在 $1\sim nk$ 之间，所以小 Ω 只需要将所有题目按照答案分成 $nk$ 类进行管理就行了，现在请你分别求出每一类中一共有多少道最大权独立集问题，对 $10^9+7$ 取模。</p>
        <p>$n\le1000$，$k\le5$。</p>

		<h3>题解</h3>
        <p>考虑树形 $\rm dp$，不妨把求最大独立集时的 $\rm dp$ 状态压入外层的 $\rm dp$ 状态中，我们就得到了一个 $\rm dp$ 套 $\rm dp$ 的做法，总状态数是 $\mathcal{O}(n\times(nk)^2)=\mathcal{O}(n^3k^2)$ 级别的，明显吃不消。</p>
        <p>进一步观察内层 $\rm dp$，设强制不选的时候的 $\rm dp$ 值为 $x$，强制选的时候的 $\rm dp$ 值为 $y$，则有 $y\le x+k$。</p>
        <p>于是我们就将 $\rm dp$ 里存储的值设为 $x$ 和 $\max(x,y)$，这样就有 $0\le\max(x,y)-x\le k$，且也是可以进行状态转移的。</p>
        <p>这样我们就将总状态数压到了 $\mathcal{O}(n\times nk\times k)=\mathcal{O}(n^2k^2)$ 级别的，转移复杂度类似树上背包，总时间复杂度 $\mathcal{O}(n^2k^2)$，可以通过。</p>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1005, K = 6, P = 1e9 + 7;

vector&lt;int&gt; G[N];
int m, siz[N], f[N][N * K][K], tmp[N * K][K];

void dfs(int x, int fa = -1)
{
    siz[x] = 1;
    for (int i = 1; i &lt;= m; ++i) {
        f[x][0][i] = 1;
    }
    for (int i = 0; i &lt; G[x].size(); ++i) {
        int v = G[x][i];
        if (v == fa) {
            continue;
        }
        dfs(v, x);
        memset(tmp, 0, sizeof(tmp));
        for (int j = 0; j &lt;= siz[x] * m; ++j) {
            for (int k = 0; k &lt;= m; ++k) {
                if (!f[x][j][k]) {
                    continue;
                }
                for (int _j = 0; _j &lt;= siz[v] * m; ++_j) {
                    for (int _k = 0; _k &lt;= m; ++_k) {
                        tmp[j + _j + _k][max(j + k + _j, j + _j + _k) - (j + _j + _k)] =
                        (tmp[j + _j + _k][max(j + k + _j, j + _j + _k) - (j + _j + _k)]
                        + 1ll * f[x][j][k] * f[v][_j][_k]) % P;
                    }
                }
            }
        }
        memcpy(f[x], tmp, sizeof(f[x]));
        siz[x] += siz[v];
    }
    return;
}

signed main()
{
    int n;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt; n; ++i) {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dfs(1);
    for (int i = 1; i &lt;= n * m; ++i) {
        int A = 0;
        for (int j = 0; j &lt;= min(i, m); ++j) {
            A = (A + f[1][i - j][j]) % P;
        }
        printf(&quot;%d\n&quot;, A);
    }
    return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>
	</body>
</html>