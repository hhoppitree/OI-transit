\documentclass[UTF8,12pt,a4paper]{ctexart} % 目录没改
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{array}
\usepackage{diagbox}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{CJKfntef}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{indentfirst}
\usepackage{amsmath,amssymb}
\usepackage{tabu}
\usepackage[colorlinks,linkcolor=blue,anchorcolor=blue,citecolor=green,bookmarks=true]{hyperref}
% \usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}
\usepackage{bookmark}
\usepackage{inconsolata}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{paralist}
\usepackage{multirow}
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{xcolor}
\usepackage{endnotes}
\usepackage{multirow}
\usepackage{notoccite}
\usepackage{longtable}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tabu}
\usepackage{xeCJK}
\usepackage{CJK}                   
\usepackage{CJKfntef}        
\usepackage{fancyhdr}               
\usepackage{graphicx}                 
\usepackage{lastpage}    
\usepackage{listings}
\usepackage{fancybox}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{layout}
\usepackage{titletoc}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{ctex}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage{xeCJKfntef, multicol}
\setlength{\parindent}{2em}
\geometry{left=2.45cm,right=2.45cm,top=2.75cm,bottom=2.6cm}
%\setcounter{secnumdepth}{0}
\let\itemize\compactitem
\let\enditemize\endcompactitem
\let\enumerate\compactenum
\let\endenumerate\endcompactenum
\let\description\compactdesc
\let\enddescription\endcompactdesc

\lstset{
	basicstyle={      
		\color{black}
		\fontspec{Consolas}
	},
	keywordstyle={
		\color{blue}
		\fontspec{Consolas}
	},
	numberstyle={
		\color{black}
		\textbf
	},
	rulecolor=\color{blue},
	numbers=left,                               
	frame=single,                            
	frameround=tttt,
	morekeywords={Sample, Input, Output},   % 可以手动添加关键字
}
\setmonofont{Consolas}
\newcommand{\stress}[1]{\textbf{\CJKunderdot{#1}}}
\newfontfamily\code{Consolas}

\definecolor{mys}{rgb}{1,0.2,0}%一个颜色
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\lstset{
	numberstyle=\ttfamily\color{codegray}
}

\linespread{1.5}%修改行距

\begin{document}
	\fontsize{12pt}{12pt}\selectfont
	%自行调整字体大小，适应排版
	%需要调整到合适的大小才能好看
	
	\newpage
	\pagestyle{fancy}
	\lhead{\footnotesize \songti{Density of subarrays}}
	\cfoot{\footnotesize 第 \thepage \ 页\qquad  共  \pageref{LastPage} 页}
	
	\phantomsection
	\addcontentsline{toc}{section}{【CF1158F】Density of subarrays}
	\section*{【CF1158F】Density of subarrays}
	\rhead{\footnotesize \songti{CF1158F}}
	
	\phantomsection
	\addcontentsline{toc}{subsection}{题目描述}
	\subsection*{【题目描述】}
	
	给定数列 $a_n$，定义 $f(a)$ 为最大的 $p$ 使得任意 $x\in[c]^{p}$ 均为 $a$ 的子序列，对于所有 $p\in[0,n]$，求 $a$ 的 $f$ 值为 $p$ 的子序列个数，对 $998244353$ 取模。
	
	$n,c\le3000$。
	
	\phantomsection
	\addcontentsline{toc}{subsection}{思路}
	\subsection*{【思路】}
	
	Step \#1：当 $a$ 确定时，如何快速计算 $f(a)$？
	
	Step \#2：设 $f_{i,j}$ 表示以 $i$ 为开头，$f$ 值至少为 $j$ 的子序列个数，最后差分即可，但是 $f$ 如何转移呢？
	
	Step \#3：再预处理出一个 $g$ 数组，其中 $g_{l,r}$ 表示开头为 $l$，结尾为 $r$ 时，有多少子序列满足 $1\sim c$ 全部出现并且 $a_r$ 仅在 $r$ 位置出现，即可快速处理 $f$，时间复杂度 $\mathcal{O}\dfrac{n^3}{c}$。
	
	Step \#4：当 $c$ 小的时候数据分治，将 $1\sim c$ 中选过的数也压进状态即可。
	
	\phantomsection
	\addcontentsline{toc}{subsection}{题解}
	\subsection*{【题解】}
	
	发现 $f(a)$ 等同于将 $a$ 从前到后扫一遍，记一个集合 $S$，初始为空，每次扫到 $a_i=x$ 时，若 $x\not\in S$，则将 $x$ 加入 $S$，若加入后 $S$ 的大小为 $c$，则将 $S$ 清空，最终 $f(a)$ 等同于 $S$ 被清空的次数，这个证明是显然的，由此还可以得到所有答案不为 $0$ 的 $p$ 都不超过 $\dfrac{n}{c}$。
	
	于是就可以 $\text{DP}$，设 $f_{i,j}$ 表示以 $i$ 为开头，$f$ 值至少为 $j$ 的子序列个数，再预处理出 $g_{l,r}$ 表示开头为 $l$，结尾为 $r$ 时，有多少子序列满足 $1\sim c$ 全部出现并且 $a_r$ 仅在 $r$ 位置出现。
	
	我们可以得到 $g_{l,r}=[a_l\ne a_r]2^{{\text cnt}_{a_l}-1}\prod\limits_{i\ne a_l\cup i\ne a_r}(2^{{\text cnt}_{a_l}}-1)$，其中 $\text{cnt}_x$ 表示 $x$ 在 $[l,r]$ 中出现的次数。
	
	而由此可以得出 $f$ 的转移式：
	
	$$
	\begin{aligned}
		f_{i,j}=\sum\limits_{k=i+1}{n}g_{i,k}\sum\limits_{l=k+1}^{n}f_{l,j-1}
	\end{aligned}
	$$
	
	用前缀和优化转移即可，时间复杂度 $\mathcal{O}\dfrac{n^3}{c}$。
	
	取一阈值 $S$，当 $c>S$ 的时候，直接用这个做法即可；当 $c\le S$ 的时候，把当前选了哪些数也压入状态即可，这样的时间复杂度是 $\mathcal{O}(n^2\dfrac{2^c}{c})$。
	
	取 $S=\log n$，得最终时间复杂度为 $\mathcal{O}(n^3\log n)$。
	
\end{document}